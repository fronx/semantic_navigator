# Cluster Labels

This document explains how cluster labels work in the Topics view.

## Overview

Cluster labels are semantic descriptions of keyword groups generated by community detection algorithms. Instead of showing raw hub keywords like "machine learning", clusters get descriptive labels like "AI & Deep Learning" from an LLM.

## Architecture

### 1. Client-Side Clustering

**Algorithm**: Leiden community detection via `graphology-communities-louvain`

**Location**: `src/lib/leiden-clustering.ts`

**Process**:
1. Build undirected graph from keyword nodes and similarity edges
2. Run Leiden algorithm with configurable resolution parameter
3. Compute betweenness centrality to identify peripheral clusters
4. Select hub keyword per cluster (highest degree, shortest label)

**Complexity**: O(n log n) for both clustering and centrality computation

**Output**:
```typescript
{
  nodeToCluster: Map<string, number>,  // Node ID → Cluster ID
  clusters: Map<number, {
    id: number,
    members: string[],       // Keyword labels in cluster
    hub: string,            // Representative keyword
    isPeripheral: boolean   // Low centrality flag
  }>
}
```

### 2. Precomputed Clusters

**Database**: `precomputed_topic_clusters` table (migration 025)

**Script**: `scripts/precompute-topic-clusters.ts`

**Structure**:
- 8 fixed resolutions: 0.1, 0.3, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0
- Stores node assignments, cluster metadata, and semantic labels
- Generated for article-level keywords only

**RPC Function**: `get_precomputed_clusters(target_resolution, node_ids[])`
- Finds nearest precomputed resolution (within ±0.15)
- Returns cluster assignments and labels

### 3. Semantic Label Generation

**LLM**: Claude Haiku via Anthropic API

**Location**: `src/lib/llm.ts` (`generateClusterLabels`)

**Prompt Strategy**:
- Provides 3-10 representative keywords per cluster
- Requests 2-4 word descriptive labels
- Examples: "reinforcement learning" → "RL & Agent Training"

**Client-Side Caching**: `src/lib/cluster-label-cache.ts`
- localStorage-based cache with semantic similarity matching
- Uses centroid embeddings to find near-matches (cosine similarity)
- Refinement API for near-matches (0.85 ≤ similarity < 0.95)
- Reduces API calls by ~80% after first run

### 4. Hook: useClusterLabels

**Location**: `src/hooks/useClusterLabels.ts`

**Behavior**:
1. Check for precomputed clusters (server-side)
2. Fall back to client-side Leiden if not available
3. Fetch semantic labels from Haiku API (with caching)
4. Return stable cluster assignments immediately
5. Update labels asynchronously when they arrive

**Return Value**:
```typescript
{
  nodeToCluster: Map<string, number>,
  baseClusters: Map<number, Omit<Cluster, "label">>,  // Stable
  clusters: Map<number, Cluster>,                     // Updates with labels
  labels: Record<number, string>                      // Semantic labels
}
```

## Data Source Separation

**IMPORTANT**: Cluster labels and chunk nodes use different data sources.

### Keyword Graph (Clustering Input)
- **Endpoint**: `/api/topics`
- **Query**: `getKeywordBackbone` → `get_article_keyword_graph` RPC
- **Filter**: `node_type = 'article'` (hardcoded in migration 017)
- **Purpose**: Main graph visualization and clustering
- **Example**: "machine learning", "neural networks", "deep learning"

### Chunk Nodes (Background Layer)
- **Endpoint**: `/api/topics/chunks`
- **Query**: Direct Supabase join on `keywords` and `nodes` tables
- **Filter**: `nodes.node_type = 'chunk'`
- **Purpose**: Text content behind frosted glass panel
- **Example**: Paragraph text from markdown chunks

**Why This Matters**: The `nodeType` parameter in `graph-queries.ts` affects community ID lookups, not chunk loading. It must be set to `'article'` to match the RPC filter and precomputed cluster data.

## Integration in TopicsView

**File**: `src/components/TopicsView.tsx`

**Flow**:
1. Fetch keyword graph via `/api/topics`
2. Run `useClusterLabels` to get clustering
3. Update effect (lines 252-338):
   - Maps hub keywords to cluster IDs
   - Sets `hullLabel` on nodes for label rendering
   - Calls renderer-specific `updateClusterLabels()` method

**Label Rendering**:
- **D3**: Direct SVG text elements via `node-renderer.ts`
- **Three.js**: DOM overlay via `label-overlays.ts`
- **R3F**: DOM overlay via `LabelsOverlay.tsx` component

## Debugging

### Check Precomputed Clusters
```bash
npm run script scripts/check-keyword-node-types.ts
```

Expected output:
- 800+ article-level keywords
- 900+ precomputed cluster rows
- Sample node_ids like `kw:machine learning`

### Console Messages
```
[cluster-labels] Using precomputed clusters (892/892 nodes)  ✓ Good
[cluster-labels] Computing clusters client-side with Leiden  ⚠️ Fallback
[cluster-cache] 23 exact hits, 5 near-matches, 2 misses    ✓ Cache working
```

### Common Issues

**No cluster labels showing**:
- Check `nodeType` in `graph-queries.ts` is `'article'`
- Verify precomputed clusters exist: `SELECT COUNT(*) FROM precomputed_topic_clusters;`
- Check console for errors from `/api/precomputed-clusters`

**Labels flashing/changing**:
- Normal behavior - hub keywords show first, semantic labels replace them
- If excessive, check cache: `localStorage.getItem('cluster-label-cache')`

**Wrong labels**:
- Precomputed clusters may be stale after re-importing articles
- Regenerate: `npm run script scripts/precompute-topic-clusters.ts`

## Performance

**Client-side clustering**: ~50-100ms for 1000 nodes, 5000 edges
**Haiku API**: ~2-5s for 30 clusters (batch request)
**Precomputed lookup**: ~50ms (database query)
**Cache hit**: <1ms (localStorage)

## References

- [Leiden algorithm paper](https://www.nature.com/articles/s41598-019-41695-z)
- Migration 025: `supabase/migrations/025_precomputed_topic_clusters.sql`
- ADR 006: Keyword node_type denormalization
- `src/lib/leiden-clustering.ts` - Core algorithm
- `src/hooks/useClusterLabels.ts` - React integration
- `scripts/precompute-topic-clusters.ts` - Batch generation
