# Cluster Labels

This document explains how cluster labels work in the Topics view.

## Overview

Cluster labels are semantic descriptions of keyword groups generated by community detection algorithms. Instead of showing raw hub keywords like "machine learning", clusters get descriptive labels like "AI & Deep Learning" from an LLM.

## Architecture

### 1. Client-Side Clustering

**Algorithm**: Leiden community detection via `graphology-communities-louvain`

**Location**: `src/lib/leiden-clustering.ts`

**Process**:
1. Build undirected graph from keyword nodes and similarity edges
2. Run Leiden algorithm with configurable resolution parameter
3. Compute betweenness centrality to identify peripheral clusters
4. Select hub keyword per cluster (highest degree, shortest label)

**Complexity**: O(n log n) for both clustering and centrality computation

**Output**:
```typescript
{
  nodeToCluster: Map<string, number>,  // Node ID → Cluster ID
  clusters: Map<number, {
    id: number,
    members: string[],       // Keyword labels in cluster
    hub: string,            // Representative keyword
    isPeripheral: boolean   // Low centrality flag
  }>
}
```

### 2. Precomputed Clusters

**Database**: `precomputed_topic_clusters` table (migration 025)

**Script**: `scripts/precompute-topic-clusters.ts`

**Structure**:
- 8 fixed resolutions: 0.1, 0.3, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0
- Stores node assignments, cluster metadata, and semantic labels
- Generated for article-level keywords only

**RPC Function**: `get_precomputed_clusters(target_resolution, node_ids[])`
- Finds nearest precomputed resolution (within ±0.15)
- Returns cluster assignments and labels

### 3. Semantic Label Generation

**LLM**: Claude Haiku via Anthropic API

**Location**: `src/lib/llm.ts` (`generateClusterLabels`)

**Prompt Strategy**:
- Provides 3-10 representative keywords per cluster
- Requests 2-4 word descriptive labels
- Examples: "reinforcement learning" → "RL & Agent Training"

**Client-Side Caching**: `src/lib/cluster-label-cache.ts`
- localStorage-based cache with semantic similarity matching
- Uses centroid embeddings to find near-matches (cosine similarity)
- Refinement API for near-matches (0.85 ≤ similarity < 0.95)
- Reduces API calls by ~80% after first run

### 4. Hook: useClusterLabels

**Location**: `src/hooks/useClusterLabels.ts`

**Behavior**:
1. Check for precomputed clusters (server-side)
2. Fall back to client-side Leiden if not available
3. Fetch semantic labels from Haiku API (with caching)
4. Return stable cluster assignments immediately
5. Update labels asynchronously when they arrive

**Return Value**:
```typescript
{
  nodeToCluster: Map<string, number>,
  baseClusters: Map<number, Omit<Cluster, "label">>,  // Stable
  clusters: Map<number, Cluster>,                     // Updates with labels
  labels: Record<number, string>                      // Semantic labels
}
```

## Data Source Separation

**IMPORTANT**: Cluster labels and chunk nodes use different data sources.

### Keyword Graph (Clustering Input)
- **Endpoint**: `/api/topics`
- **Query**: `getKeywordBackbone` → `get_article_keyword_graph` RPC
- **Filter**: `node_type = 'article'` (hardcoded in migration 017)
- **Purpose**: Main graph visualization and clustering
- **Example**: "machine learning", "neural networks", "deep learning"

### Chunk Nodes (Background Layer)
- **Endpoint**: `/api/topics/chunks`
- **Query**: Direct Supabase join on `keywords` and `nodes` tables
- **Filter**: `nodes.node_type = 'chunk'`
- **Purpose**: Text content behind frosted glass panel
- **Example**: Paragraph text from markdown chunks

**Why This Matters**: The `nodeType` parameter in `graph-queries.ts` affects community ID lookups, not chunk loading. It must be set to `'article'` to match the RPC filter and precomputed cluster data.

## Cluster ID Routing

**CRITICAL**: Two clustering systems produce different cluster IDs that must not be confused.

### MapView Clustering (node.communityId)
- **Algorithm**: Louvain (8-level hierarchy)
- **Storage**: `keyword_communities` table
- **Purpose**: MapView visualization (article-keyword bipartite graph)
- **ID Range**: 0-N (assigned by database)

### TopicsView Clustering (nodeToCluster map)
- **Algorithm**: Leiden (runtime or precomputed)
- **Source**: `useClusterLabels()` hook
- **Purpose**: TopicsView cluster labels and filtering
- **ID Range**: 0-M (assigned dynamically per resolution)

### Why This Matters

**Problem**: SimNodes inherit `node.communityId` from MapView's keyword graph, but TopicsView cluster labels need Leiden cluster IDs from `nodeToCluster`.

**Solution**: The `nodeToCluster` map is passed through the renderer chain to override `node.communityId` when computing cluster labels.

**Implementation Flow**:
1. `TopicsView` gets `nodeToCluster` from `useClusterLabels()`
2. Passes to `R3FTopicsCanvas` as prop
3. Stored in `nodeToClusterRef` (part of `LabelRefs`)
4. Passed to `LabelsOverlay` via labelRefs
5. Passed to `createLabelOverlayManager()` as `getNodeToCluster`
6. Used in `computeClusterLabels()` to group nodes by Leiden cluster ID

**Files involved**:
- `src/components/TopicsView.tsx` - Sources `nodeToCluster`
- `src/components/topics-r3f/R3FTopicsCanvas.tsx` - Accepts prop, creates ref
- `src/components/topics-r3f/R3FLabelContext.tsx` - Defines `LabelRefs` type
- `src/components/topics-r3f/LabelsOverlay.tsx` - Passes ref to label manager
- `src/lib/label-overlays.ts` - Accepts `getNodeToCluster` callback
- `src/lib/cluster-labels.ts` - Uses `nodeToCluster` to group nodes

### Cluster Color Routing

**Problem**: Cluster colors must also use Leiden cluster IDs to match the semantic colors of nodes within each cluster. If colors are computed using MapView's `node.communityId`, label colors won't predict the colors of their member nodes.

**Solution**: In `R3FTopicsScene.tsx`, cluster colors are computed by grouping nodes with `nodeToCluster` (Leiden IDs) instead of `groupNodesByCommunity()` (MapView IDs).

**Implementation**:
```typescript
// R3FTopicsScene.tsx (lines 117-122)
const nodeToCluster = labelRefs.nodeToClusterRef.current;
const grouped = nodeToCluster.size > 0
  ? groupNodesByMap(simNodes, nodeToCluster)  // Use Leiden IDs
  : groupNodesByCommunity(simNodes);          // Fallback to MapView IDs
const colors = computeClusterColors(grouped, pcaTransform);
labelRefs.clusterColorsRef.current = colors;
```

**Result**: Cluster labels inherit colors from the semantic embeddings (PCA-projected hues) of their member nodes, creating visual consistency between labels and the nodes they represent.

**Why This Matters**: Without this routing, a cluster labeled "Machine Learning" might be blue while its member nodes are orange, breaking visual coherence and making it harder for users to understand cluster membership at a glance.

## Integration in TopicsView

**File**: `src/components/TopicsView.tsx`

**Flow**:
1. Fetch keyword graph via `/api/topics`
2. Run `useClusterLabels` to get clustering (produces `nodeToCluster` map)
3. Pass `nodeToCluster` to R3F renderer for label rendering
4. Cluster labels are computed using Leiden IDs from `nodeToCluster`
5. Cluster colors are computed from Leiden clusters (ensures labels match node colors)
6. Clicking a cluster label filters graph to show only that cluster's members

**Label Rendering**:
- **D3**: Direct SVG text elements via `node-renderer.ts`
- **Three.js**: DOM overlay via `label-overlays.ts`
- **R3F**: DOM overlay via `LabelsOverlay.tsx` component (primary renderer)

**Click-to-Filter**:
- Cluster labels are clickable (cursor: pointer)
- Click handler: `handleClusterLabelClick` in TopicsView
- Applies cluster filter via `useTopicsFilter.applyClusterFilter()`
- Filters graph to show only keywords in clicked cluster

## Debugging

### Check Precomputed Clusters
```bash
npm run script scripts/check-keyword-node-types.ts
```

Expected output:
- 800+ article-level keywords
- 900+ precomputed cluster rows
- Sample node_ids like `kw:machine learning`

### Console Messages
```
[cluster-labels] Using precomputed clusters (892/892 nodes)  ✓ Good
[cluster-labels] Computing clusters client-side with Leiden  ⚠️ Fallback
[cluster-cache] 23 exact hits, 5 near-matches, 2 misses    ✓ Cache working
```

### Common Issues

**No cluster labels showing**:
- Check `nodeType` in `graph-queries.ts` is `'article'`
- Verify precomputed clusters exist: `SELECT COUNT(*) FROM precomputed_topic_clusters;`
- Check console for errors from `/api/precomputed-clusters`

**Labels flashing/changing**:
- Normal behavior - hub keywords show first, semantic labels replace them
- If excessive, check cache: `localStorage.getItem('cluster-label-cache')`

**Wrong labels**:
- Precomputed clusters may be stale after re-importing articles
- Regenerate: `npm run script scripts/precompute-topic-clusters.ts`

## Performance

**Client-side clustering**: ~50-100ms for 1000 nodes, 5000 edges
**Haiku API**: ~2-5s for 30 clusters (batch request)
**Precomputed lookup**: ~50ms (database query)
**Cache hit**: <1ms (localStorage)

## References

- [Leiden algorithm paper](https://www.nature.com/articles/s41598-019-41695-z)
- Migration 025: `supabase/migrations/025_precomputed_topic_clusters.sql`
- ADR 006: Keyword node_type denormalization
- `src/lib/leiden-clustering.ts` - Core algorithm
- `src/hooks/useClusterLabels.ts` - React integration
- `scripts/precompute-topic-clusters.ts` - Batch generation
